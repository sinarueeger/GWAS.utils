expect_message(eaf2maf(c(0.2, Inf), "The 'eaf' vector contains infinite values. These will be turned into NAs.")
expect_failure(eaf2maf(NULL), "No 'eaf' vector provided.")
expect_failure(eaf2maf(), "No 'eaf' vector provided.")
expect_failure(eaf2maf("A"), "'eaf' must be a numeric vector.")
})
expect_message(eaf2maf(c(0.2, Inf)), "The 'eaf' vector contains infinite values. These will be turned into NAs.")
expect_warning(eaf2maf(c(0.2, Inf)), "The 'eaf' vector contains infinite values. These will be turned into NAs.")
expect_error(eaf2maf("A"), "'eaf' must be a numeric vector.")
test_that("Testing other input than numerical in EAF (NA, Inf, NULL, empty, characters)", {
expect_error(eaf2maf(NA), "All values in 'eaf' are NA.")
expect_warning(eaf2maf(c(0.2, Inf)), "The 'eaf' vector contains infinite values. These will be turned into NAs.")
expect_error(eaf2maf(NULL), "No 'eaf' vector provided.")
expect_error(eaf2maf(), "No 'eaf' vector provided.")
expect_error(eaf2maf("A"), "'eaf' must be a numeric vector.")
})
test_that("Testing EAF vector with NA, 0, 1, 0.7", {
expect_equal(eaf2maf(c(NA, 0, 1, 0.7)), c(NA, 0, 0, 0.3))
})
test_that("Testing EAF = 0 and EAF = 1", {
expect_equal(eaf2maf(0), 0)
expect_equal(eaf2maf(1), 0)
})
test_that("Testing other input than numerical in EAF (NA, Inf, NULL, empty, characters)", {
expect_error(eaf2maf(NA), "All values in 'eaf' are NA.")
expect_warning(eaf2maf(c(0.2, Inf)), "The 'eaf' vector contains infinite values. These will be turned into NAs.")
expect_error(eaf2maf(NULL), "No 'eaf' vector provided.")
expect_error(eaf2maf(), "No 'eaf' vector provided.")
expect_error(eaf2maf("A"), "'eaf' must be a numeric vector.")
})
test_that("Testing numerical values", {
expect_equal(eaf2maf(0.5), 0.5)
expect_equal(eaf2maf(0), 0)
expect_equal(eaf2maf(1), 0)
expect_equal(eaf2maf(0.51), 0.49)
})
devtools::load_all(".")
install.packages("gridExtra")
Z <- 200
z2p <- function(Z)
{
exp(pnorm(abs(Z),log.p=TRUE, lower = FALSE))*2
}
library(readr)
Meta_analysis_Locke_et_al_UKBiobank_2018_UPDATED <- read_table2("~/Downloads/Meta-analysis_Locke_et_al+UKBiobank_2018_UPDATED")
View(Meta_analysis_Locke_et_al_UKBiobank_2018_UPDATED)
dat <- Meta_analysis_Locke_et_al_UKBiobank_2018_UPDATED
dat <- dat %>% mutate(Z = BETA/SE)
range(dat$Z)
dat$P2 <- z2p(dat$Z)
plot(dat$P2, dat$P)
head(dat)
View(Meta_analysis_Locke_et_al_UKBiobank_2018_UPDATED)
expect_equal(10, 10 + 1e-7)
expect_identical(10, 10 + 1e-7)
pnorm(1.96)
pnorm(1.96, lower = FALSE)
pnorm(1.96, lower = FALSE) * 2
pnorm(0, lower = FALSE) * 2
expect_equal(z2p(c(NA, 1.96, -1.96, 0)), c(NA, 0.05, 0.05, 1))
qnorm(0.05)
qnorm(0.05/2)
expect_equal(z2p(c(NA, 1.959, -1.959, 0)), c(NA, 0.05, 0.05, 1))
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA, 0.05, 0.05, 1))
z2p(NA)
z2p(Inf)
z2p(-Inf)
pnorm(Inf, lower = FALSE) * 2
pnorm(-Inf, lower = FALSE) * 2
z2p <- function(Z)
{
if (any(is.infinite(Z)))
{
warning("The 'eaf' vector contains infinite values. These will be turned into NAs.")
is.na(Z) <- is.infinite(Z)
}
exp(pnorm(abs(Z),log.p=TRUE, lower = FALSE))*2
}
expect_warning(z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs.")
z2p <- function(Z)
{
if (any(is.infinite(Z)))
{
warning("The 'Z' vector contains infinite values. These will be turned into NAs.")
is.na(Z) <- is.infinite(Z)
}
exp(pnorm(abs(Z),log.p=TRUE, lower = FALSE))*2
}
expect_warning(z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs.")
z2p(NULL)
test_that("P 0.05 and Z 1.96", {
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA, 0.05, 0.05, 1))
})
test_that("Testing NAs and Inf", {
expect_equal(z2p(c(NA, NA)), c(NA, NA))
expect_warning(z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs.")
})
z2p(c(NA, NA))
expect_equal(z2p(c(NA, NA)), c(NA_integer_, NA_integer_))
test_that("Testing EAF vector with NA, 0, 1, 0.7", {
expect_equal(eaf2maf(c(NA, 0, 1, 0.7)), c(NA_integer_, 0, 0, 0.3))
})
test_that("P 0.05 and Z 1.96", {
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
})
test_that("Testing NAs and Inf", {
expect_equal(z2p(c(NA, NA)), c(NA_integer_, NA_integer_))
expect_warning(z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs.")
})
z2p(c(200, 300))
z2p <- function(Z)
{
if (any(is.infinite(Z)))
{
warning("The 'Z' vector contains infinite values. These will be turned into NAs, because no meaninful P value can be calculated from that.")
is.na(Z) <- is.infinite(Z)
}
exp(pnorm(abs(Z),log.p=TRUE, lower = FALSE))*2
}
log(2) + pnorm(abs(z), lower.tail=FALSE, log.p=TRUE))
log(2) + pnorm(abs(200), lower.tail=FALSE, log.p=TRUE)
log(2)
exp(log(2) + pnorm(abs(200), lower.tail=FALSE, log.p=TRUE))
exp(log(2) + pnorm(abs(20), lower.tail=FALSE, log.p=TRUE))
?pnorm
Z <- 2
Z <- 20
exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
2*Rmpfr::pnorm(mpfr(40, precBits=100), lower.tail=FALSE, log.p = FALSE)
install.packages("Rmpfr")
Rmpfr::pnorm(mpfr(abs(Z), precBits=100), lower.tail=FALSE, log.p = FALSE)
Z
mpfr
library(Rmpfr)
Rmpfr::pnorm(mpfr(abs(Z), precBits=100), lower.tail=FALSE, log.p = FALSE)
Z
Z <- 100
Rmpfr::pnorm(mpfr(abs(Z), precBits=100), lower.tail=FALSE, log.p = FALSE)
P <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
P
Z <- seq(-200, 200, by = 2)
Z
P1 <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
P2 <-
2 * Rmpfr::pnorm(mpfr(abs(Z), precBits = 100),
lower.tail = FALSE,
log.p = FALSE)
plot(P1, P2)
plot(P1, P2)
plot(-log10(P1), -log10(P2))
P2 <-
2 * Rmpfr::pnorm(mpfr(abs(Z), precBits = 100),
lower.tail = TRUE)
plot(-log10(P1), -log10(P2))
?Rmpfr::pnorm
Z
P0 <- pnorm(abs(Z)) *2
P1 <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
P2 <-
2 * Rmpfr::pnorm(mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
plot(-log10(P1), -log10(P0))
Z <- 2
P0 <- pnorm(abs(Z)) *2
P0
P0 <- pnorm(abs(Z)) *2
P0
pnorm(2)
pnorm(2, lower = TRUE)
pnorm(2, lower = FALSE)
pnorm(2, lower = FALSE) * 2
P0 <- pnorm(abs(Z), lower = FALSE) *2
Z <- seq(-200, 200, by = 2)
P0 <- pnorm(abs(Z), lower = FALSE) *2
plot(-log10(P1), -log10(P0))
abline(0,1)
plot(-log10(P1), -log10(P2))
qplot(-log10(P1), -log10(P2))
qplot(-log10(P1), -log10(P2))
P2
2 * Rmpfr::pnorm(mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE) %>% as.numeric()
P2 <-
2 * Rmpfr::pnorm(mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE) %>% as.numeric()
qplot(-log10(P1), -log10(P2))
cbind(P0, P2)
cbind(P0, P1)
Z[120]
P <-
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
hist(P)
hist(-log10(P))
-log10(P)
plot(as.numeric(-log10(P)), -log(P1))
abline(0, 1)
P1
-log10(p1)
-log10(P1)
plot(as.numeric(-log10(P)), -log10(P1))
abline(0, 1)
z2p <- function(Z)
{
if (any(is.infinite(Z)))
{
warning(
"The 'Z' vector contains infinite values. These will be turned into NAs, because no meaninful P value can be calculated from that."
)
is.na(Z) <- is.infinite(Z)
}
if (method == "pnorm") {
P <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
if (any(P == 0))
{
warning("Some P-values are equal to 0. Try using the option method = 'Rmpfr::pnorm'")
}
}
if (method == "Rmpfr::pnorm") {
## from https://stackoverflow.com/questions/46416027/how-to-compute-p-values-from-z-scores-in-r-when-the-z-score-is-large-pvalue-muc
sprintf("using method Rmpfr::")
P <-
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
}
return(P)
}
devtools::load_all(".")
install.packages("ggrepel")
devtools::load_all(".")
devtools::load_all(".")
test_that("Z can be very large", {
expect_equal(z2p(c(200, 300)), c())
})
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
devtools::load_all(".")
z2p
devtools::load_all(".")
z2p
devtools::load_all(".")
z2p
devtools::load_all(".")
z2p
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
Z <- c(NA, 1.959964, -1.959964, 0)
Z
any(is.infinite(Z))
P <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
P
any(P == 0)
any(P == 0, na.rm = TRUE)
any(is.infinite(Z))
devtools::load_all(".")
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
Z
P <- exp(pnorm(abs(Z), log.p = TRUE, lower = FALSE)) * 2
if (any(P == 0, na.rm = TRUE))
{
warning("Some P-values are equal to 0. Try using the option method = 'Rmpfr::pnorm'")
}
devtools::load_all(".")
z2p
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm")), c(NA_integer_, 0.05, 0.05, 1))
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm"), c(NA_integer_, 0.05, 0.05, 1))
Z
sprintf("using method Rmpfr::")
P <-
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
Z
Z <- NA
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
?Rmpfr::pnorm
Rmpfr::mpfr(abs(Z), precBits = 100)
devtools::load_all(".")
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm"), c(NA_integer_, 0.05, 0.05, 1))
Z
c(NA, 1.959964, -1.959964, 0)
Z <- c(NA, 1.959964, -1.959964, 0)
P <- NA
P[!is.na(Z)] <-
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z[!is.na(Z)]), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
P
2 * Rmpfr::pnorm(abs(Z[!is.na(Z)]),
lower.tail = FALSE, log.p = FALSE)
Z <- c(NA, 200)
2 * Rmpfr::pnorm(abs(Z[!is.na(Z)]),
lower.tail = FALSE, log.p = FALSE)
2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
?mpfr
Rmpfr::mpfr(abs(Z), precBits = 100, rnd.mode = "N")
P <- Rmpfr::mpfr(abs(Z), precBits = 100)
P[!is.na(Z)] <- 2 * Rmpfr::pnorm(Rmpfr::mpfr(abs(Z[!is.na(Z)] ), precBits = 100),
lower.tail = FALSE, log.p = FALSE)
P
devtools::load_all(".")
z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm")
expect_equal(z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm"), c(NaN_integer_, 0.05, 0.05, 1))
z2p(c(NA, NA))
expect_equal(z2p(c(NA, NA)), c(NA_integer_, NA_integer_))
expect_warning(z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs, because no meaninful P value can be calculated from that.")
c(200, 300), method = "Rmpfr::pnorm")
z2p(c(200, 300), method = "Rmpfr::pnorm")
dput(z2p(c(200, 300), method = "Rmpfr::pnorm"))
expect_equal(z2p(c(200, 300), method = "Rmpfr::pnorm"), new("mpfr", .Data = list(new("mpfr1", prec = 100L, exp = c(-28861L,
-1L), sign = 1L, d = c(-1342177280L, 879260022L, -1492104513L,
-1945735537L)), new("mpfr1", prec = 100L, exp = c(-64929L, -1L
), sign = 1L, d = c(1879048192L, -2068401488L, 1783661392L, -1881304130L
)))))
z2p(c(200, 300)
)
expect_warning(z2p(c(200, 300)), "Some P-values are equal to 0. Try using the option method = 'Rmpfr::pnorm'")
expect_equal(z2p(c(200, 300)), c(0,0))
test_that("Z can be very large", {
expect_equal(z2p(c(200, 300)), c(0,0))
expect_warning(z2p(c(200, 300)), "Some P-values are equal to 0. Try using the option method = 'Rmpfr::pnorm'")
expect_equal(z2p(c(200, 300), method = "Rmpfr::pnorm"), new("mpfr", .Data = list(new("mpfr1", prec = 100L, exp = c(-28861L,
})
expect_equal(z2p(c(4, 1.959964,-1.959964, 0)), z2p(c(4, 1.959964,-1.959964, 0), method = "Rmpfr::pnorm") %>% as.numeric())
dput(z2p(c(200, 300), method = "Rmpfr::pnorm"))
test_that("P 0.05 and Z 1.96", {
expect_equal(z2p(c(NA, 1.959964,-1.959964, 0)), c(NA_integer_, 0.05, 0.05, 1))
expect_equal(z2p(c(4, 1.959964,-1.959964, 0)), z2p(c(4, 1.959964,-1.959964, 0), method = "Rmpfr::pnorm") %>% as.numeric())
#  expect_equal(z2p(c(NA, 1.959964, -1.959964, 0), method = "Rmpfr::pnorm"), c(NaN_integer_, 0.05, 0.05, 1))
})
test_that("Z can be very large", {
expect_equal(z2p(c(200, 300)), c(0, 0))
expect_warning(z2p(c(200, 300)),
"Some P-values are equal to 0. Try using the option method = 'Rmpfr::pnorm'")
expect_equal(z2p(c(200, 300), method = "Rmpfr::pnorm"), new("mpfr", .Data = list(new("mpfr1", prec = 100L, exp = c(-28861L,
-1L), sign = 1L, d = c(-1342177280L, 879260022L, -1492104513L,
-1945735537L)), new("mpfr1", prec = 100L, exp = c(-64929L, -1L
), sign = 1L, d = c(1879048192L, -2068401488L, 1783661392L, -1881304130L
)))))
})
test_that("Testing NAs and Inf", {
expect_equal(z2p(c(NA, NA)), c(NA_integer_, NA_integer_))
expect_warning(
z2p(c(0.2, Inf)),
"The 'Z' vector contains infinite values. These will be turned into NAs, because no meaninful P value can be calculated from that."
)
})
devtools::load_all(".")
QQplot(runif(100))
QQplot(runif(100), add = TRUE, col = "green")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?z2p
?z2p
?QQplot
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?z2
?z2p
dat.sim <- tibble::tibble(g = rnorm(100)) %>% dplyr::mutate(g2 = g*2)
mat <- diag(2)
mat[1,1] <- NA
eff_number_tests(mat)
#' Effective number of tests
#'
#' Calculates the effective number of tests performed in a GWAS, given the LD structure among the SNPs. SNPs that are highly correlated are not counted twice.
#'
#' @param mat matrix, either individual by SNPs (n x p) matrix, or correlation matrix between SNPs
#' @param cor.true indicates if option mat is a correlation matrix or not
#'
#' @return \code{zhc.correction} number of effective tests
#' @export
#'
#' @references Implemented from \link{https://www.ncbi.nlm.nih.gov/pubmed/18271029}
#'
#' @examples
#'
#' dat.sim <- tibble::tibble(g = rnorm(100)) %>% dplyr::mutate(g2 = g*2)
#' eff_nbr_tests(diag(10), cor.true = TRUE) ## 10, because all are independent
#' eff_nbr_tests(dat.sim, cor.true = FALSE)
eff_nbr_tests <- function(mat, cor.true = FALSE)
{
if(!cor.true)
{
cor.mat <- cor(mat, use = 'pairwise.complete.obs')
}else{
cor.mat <- mat
}
cor.mat[which(is.na(cor.mat))] <- 0
svd.data <- svd(cor.mat)
sum.tp         <- 0
zhc.correction <- 0
while (sum.tp/sum(svd.data$d) < 0.995)
{
zhc.correction     <- zhc.correction+1
sum.tp <- sum.tp+svd.data$d[zhc.correction]
}
return(zhc.correction)
}
eff_nbr_tests(mat)
geno.mat <- tibble::tibble(g = rnorm(100)) %>% mutate(g2 = g*2)
geno.mat <- tibble::tibble(g = rnorm(100)) %>% mutate(g2 = g*2)
cor.mat <- diag(2)
cor.mat[1,1] <- NA
cor.mat.na <- cor.mat
geno.mat.na <- geno.mat
geno.mat <- tibble::tibble(g = rnorm(100)) %>% mutate(g2 = g*2)
cor.mat <- diag(2)
test_that("test simple values", {
expect_equal(f.eff.number.tests(diag(2), cor.true = TRUE), 2)
expect_equal(f.eff.number.tests(diag(10), cor.true = TRUE), 10)
expect_equal(f.eff.number.tests(geno.mat, cor.true = FALSE), 1)
})
cor.mat.na <- cor.mat
geno.mat.na <- geno.mat
cor.mat.na[1,1] <- NA
geno.mat.na[22, 2] <- NA
test_that("test simple values", {
expect_equal(f.eff.number.tests(cor.mat, cor.true = TRUE), 2)
expect_equal(f.eff.number.tests(diag(10), cor.true = TRUE), 10)
expect_equal(f.eff.number.tests(geno.mat, cor.true = FALSE), 1)
})
cor.mat.na <- cor.mat
geno.mat.na <- geno.mat
test_that("test simple values", {
expect_equal(eff_nbr_tests(cor.mat, cor.true = TRUE), 2)
expect_equal(eff_nbr_tests(diag(10), cor.true = TRUE), 10)
expect_equal(eff_nbr_tests(geno.mat, cor.true = FALSE), 1)
})
cor.mat.na <- cor.mat
geno.mat.na <- geno.mat
cor.mat.na[1,1] <- NA
geno.mat.na[22, 2] <- NA
expect_equal(eff_nbr_tests(cor.mat.na), 1)
eff_nbr_tests(geno.mat.na)
test_that("Testing matrices with NAs", {
expect_equal(eff_nbr_tests(cor.mat.na, cor.true = TRUE), 1)
expect_equal(eff_nbr_tests(geno.mat.na), 1)
})
trans_inv_normal{
qnorm((rank(x, na.last = "keep") - 0.5) / sum(!is.na(x)))
}
trans_inv_normal{
qnorm((rank(x, na.last = "keep") - 0.5) / sum(!is.na(x)))
}
trans_inv_normal <- function(x) {
qnorm((rank(x, na.last = "keep") - 0.5) / sum(!is.na(x)))
}
X <- runif(1000)
X.trans <- trans_inv_normal(X)
par(mfrow = c(1,2))
hist(X)
hist(X.trans)
par(mfrow = c(1,2))
qqnorm(X)
qqnorm(X.trans)
N <- sum(!is.na(x))
trans_inv_normal <- function(x, const = 3/8) {
rank.x <- rank(x, na.last = "keep")
N <- sum(x, na.rm = TRUE)
qnorm((rank.x - c.const) / (N - 2 * c.const + 1)
}
trans_inv_normal <- function(x, const = 3/8) {
rank.x <- rank(x, na.last = "keep")
N <- sum(x, na.rm = TRUE)
qnorm((rank.x - const) / (N - 2 * const + 1))
}
X.trans <- trans_inv_normal(X)
trans_inv_normal <- function(x, const = 3/8) {
rank.x <- rank(x, na.last = "keep")
N <- length(na.omit(x))
qnorm((rank.x - const) / (N - 2 * const + 1))
}
X.trans <- trans_inv_normal(X)
qqnorm(X.trans)
expect_equal(trans_inv_normal(NA), NA_integer_)
vec.normal <- rnorm(100)
vec.normal
qqnorm(vec.normal)
vec.normal <- rnorm(1000)
qqnorm(vec.normal)
expect_equal(trans_inv_normal(vec.normal), vec.normal)
vec.normal <- rnorm(1000)
vec.normal <- rnorm(10000)
expect_equal(trans_inv_normal(vec.normal), vec.normal)
expect_more_than()
?expect_more_than
expect_gt()
expect_gt
?expect_gt
expect_gt(trans_inv_normal(vec.normal) - vec.normal)
trans_inv_normal(vec.normal)
trans_inv_normal(vec.normal) - vec.normal
?expect_less_than
expect_less_than
?expect_lt
expect_lt
expect_lt(trans_inv_normal(vec.normal) - vec.normal, 0.5)
range(trans_inv_normal(vec.normal) - vec.normal)
set.seed(3)
vec.normal <- rnorm(10000)
test_that("inv.normal of NA", {
expect_equal(trans_inv_normal(NA), NA_integer_)
expect_lt(trans_inv_normal(vec.normal) - vec.normal, 0.5)
})
expect_equal(trans_inv_normal(NA), NA_integer_)
devtools::install_github("sinarueeger/GWAS.utils")
